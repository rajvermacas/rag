<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RAG Document Chat</title>
  <link rel="stylesheet" href="/static/css/output.css" />
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.2.6/dist/purify.min.js"></script>
  <script src="/static/js/chat_highlight.js"></script>
  <script src="/static/js/chat_storage_migration.js"></script>
</head>
<body class="min-h-screen bg-zinc-100 text-zinc-900">
  <main class="mx-auto max-w-6xl px-4 py-8 md:py-12">
    <header class="mb-8 rounded-2xl border border-zinc-200 bg-white/90 p-6 shadow-xl shadow-zinc-300/40 backdrop-blur">
      <div>
        <p class="text-xs font-semibold uppercase tracking-[0.2em] text-red-600">RAG Workspace</p>
        <h1 class="text-3xl font-black tracking-tight text-zinc-950 md:text-4xl">Document Intelligence Chat</h1>
        <p class="mt-2 max-w-2xl text-sm text-zinc-600">
          Upload files, chat with grounded answers, and manage indexed documents in one workspace.
        </p>
      </div>
    </header>

    <section class="grid gap-6 rounded-2xl border border-zinc-200 bg-white p-4 shadow-xl shadow-zinc-300/30 md:grid-cols-[minmax(20rem,24rem)_1fr] md:p-6">
      <article class="rounded-xl border border-zinc-200 bg-zinc-50 p-4">
        <h2 class="text-lg font-bold text-zinc-950">Upload Document</h2>
        <p class="mt-1 text-sm text-zinc-600">Accepted formats: PDF, DOCX, TXT.</p>
        <form id="upload-form" class="mt-4 space-y-3">
          <input
            class="w-full rounded-lg border border-zinc-300 bg-white px-3 py-2 text-sm text-zinc-900 file:mr-3 file:rounded-md file:border-0 file:bg-red-600 file:px-3 file:py-2 file:text-sm file:font-semibold file:text-white hover:file:bg-red-700"
            type="file"
            name="file"
            accept=".pdf,.docx,.txt"
            required
          />
          <button
            id="upload-button"
            class="inline-flex w-full items-center justify-center rounded-lg border border-red-700 bg-red-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-red-700 disabled:cursor-not-allowed disabled:opacity-60"
            type="submit"
          >
            <span
              id="upload-loader"
              class="mr-2 hidden h-4 w-4 animate-spin rounded-full border-2 border-white border-t-transparent"
              aria-hidden="true"
            ></span>
            <span id="upload-button-label">Upload</span>
          </button>
        </form>
        <div id="upload-status" class="mt-3 hidden rounded-lg border px-3 py-2 text-sm font-medium"></div>

        <section class="mt-6 rounded-xl border border-zinc-200 bg-white p-3">
          <div class="flex items-center justify-between gap-2">
            <h3 class="text-sm font-bold uppercase tracking-wide text-zinc-700">Indexed Documents</h3>
            <button
              id="refresh-documents"
              class="rounded-md border border-zinc-300 bg-white px-2.5 py-1.5 text-xs font-semibold text-zinc-700 transition hover:border-red-500 hover:text-red-600"
              type="button"
            >
              Refresh
            </button>
          </div>
          <ul id="documents-list" class="mt-3 space-y-2"></ul>
          <p id="documents-status" class="mt-3 text-xs text-zinc-600"></p>
        </section>
      </article>

      <article class="rounded-xl border border-zinc-200 bg-white p-4">
        <h2 class="text-lg font-bold text-zinc-950">Chat</h2>
        <div class="mt-3 flex flex-col gap-2 sm:flex-row sm:items-center">
          <label for="chat-history-select" class="text-sm font-semibold text-zinc-700">Chat History</label>
          <select
            id="chat-history-select"
            class="rounded-lg border border-zinc-300 bg-white px-3 py-2 text-sm text-zinc-900 outline-none transition focus:border-red-500 focus:ring-2 focus:ring-red-500/20"
          ></select>
          <button
            id="clear-chat"
            class="rounded-lg border border-zinc-300 bg-white px-3 py-2 text-sm font-semibold text-zinc-700 transition hover:border-red-500 hover:text-red-600 sm:ml-auto"
            type="button"
          >
            New Chat
          </button>
        </div>
        <div
          id="chat-window"
          class="mt-3 h-[32rem] overflow-y-auto rounded-xl border border-zinc-200 bg-zinc-50 p-3"
        ></div>
        <form id="chat-form" class="mt-4 flex flex-col gap-3 sm:flex-row">
          <input
            class="flex-1 rounded-lg border border-zinc-300 bg-white px-3 py-2 text-sm text-zinc-900 outline-none transition focus:border-red-500 focus:ring-2 focus:ring-red-500/20"
            type="text"
            name="message"
            placeholder="Ask a question about uploaded documents..."
            required
          />
          <button
            id="chat-button"
            class="inline-flex items-center justify-center rounded-lg border border-zinc-900 bg-zinc-900 px-4 py-2 text-sm font-semibold text-white transition hover:bg-zinc-800 disabled:cursor-not-allowed disabled:opacity-60"
            type="submit"
          >
            Send
          </button>
        </form>
      </article>
    </section>
  </main>

  <script>
    if (typeof marked === "undefined") {
      throw new Error("marked is required for markdown rendering");
    }
    if (typeof DOMPurify === "undefined") {
      throw new Error("DOMPurify is required for markdown rendering");
    }
    if (typeof applyDocumentHighlights === "undefined") {
      throw new Error("chat_highlight.js is required for citation highlighting");
    }
    if (typeof migrateLegacyChatState === "undefined") {
      throw new Error("chat_storage_migration.js is required for persisted state migration");
    }

    const CHAT_STORAGE_KEY = "rag-chat-sessions";
    const CITATION_ARTIFACT_PATTERN = /\[[^\]\n]*(?:#chunk_id\s*=\s*\d+|#\d+)[^\]\n]*\]/gi;

    const uploadForm = requireElement("upload-form");
    const uploadButton = requireElement("upload-button");
    const uploadLoader = requireElement("upload-loader");
    const uploadButtonLabel = requireElement("upload-button-label");
    const uploadStatus = requireElement("upload-status");
    const refreshDocuments = requireElement("refresh-documents");
    const documentsList = requireElement("documents-list");
    const documentsStatus = requireElement("documents-status");
    const chatForm = requireElement("chat-form");
    const chatButton = requireElement("chat-button");
    const chatWindow = requireElement("chat-window");
    const chatHistorySelect = requireElement("chat-history-select");
    const clearChatButton = requireElement("clear-chat");

    const chatSessions = [];
    let activeSessionId = "";
    let conversationHistory = [];

    marked.setOptions({
      breaks: true,
      gfm: true,
    });

    uploadForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      uploadButton.disabled = true;
      setUploadButtonLoadingState(true);
      setUploadStatus("hidden", "");
      try {
        const formData = new FormData(uploadForm);
        const response = await fetch("/upload", {
          method: "POST",
          body: formData,
        });
        const payload = await response.json();
        if (!response.ok) {
          setUploadStatus("error", `Upload failed: ${requireString(payload, "detail", "upload error")}`);
          return;
        }
        requireString(payload, "doc_id", "upload response");
        requireNumber(payload, "chunks_indexed", "upload response");
        setUploadStatus("success", "Document uploaded successfully.");
        uploadForm.reset();
        await loadDocuments();
      } finally {
        uploadButton.disabled = false;
        setUploadButtonLoadingState(false);
      }
    });

    refreshDocuments.addEventListener("click", async () => {
      await loadDocuments();
    });

    clearChatButton.addEventListener("click", () => {
      clearActiveChat();
    });

    chatHistorySelect.addEventListener("change", () => {
      const selectedSessionId = chatHistorySelect.value;
      setActiveSession(selectedSessionId);
      renderChatHistoryOptions();
      renderActiveSessionMessages();
      persistChatState();
    });

    chatForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      chatButton.disabled = true;
      try {
        const formData = new FormData(chatForm);
        const rawMessage = formData.get("message");
        if (typeof rawMessage !== "string") {
          throw new Error("message field is required");
        }
        const message = rawMessage.trim();
        if (message === "") {
          return;
        }

        appendUserMessage(message);
        conversationHistory.push({ role: "user", message });
        persistChatState();
        chatForm.reset();

        const thinkingMessageId = appendThinkingMessage();
        try {
          const chatResult = await fetchAssistantResponse(message, conversationHistory);
          removeMessageById(thinkingMessageId);
          appendAssistantMessage(chatResult.answer, chatResult.citations);
          conversationHistory.push({ role: "assistant", message: chatResult.answer });
          persistChatState();
        } catch (error) {
          removeMessageById(thinkingMessageId);
          appendSystemError(requireErrorMessage(error));
        }
      } finally {
        chatButton.disabled = false;
      }
    });

    window.addEventListener("load", async () => {
      initializeChatSessions();
      await loadDocuments();
    });

    function requireElement(id) {
      const element = document.getElementById(id);
      if (element === null) {
        throw new Error(`missing required element: ${id}`);
      }
      return element;
    }

    function requireString(record, key, context) {
      if (!(key in record)) {
        throw new Error(`missing '${key}' in ${context}`);
      }
      const value = record[key];
      if (typeof value !== "string") {
        throw new Error(`'${key}' must be a string in ${context}`);
      }
      return value;
    }

    function requireNumber(record, key, context) {
      if (!(key in record)) {
        throw new Error(`missing '${key}' in ${context}`);
      }
      const value = record[key];
      if (typeof value !== "number") {
        throw new Error(`'${key}' must be a number in ${context}`);
      }
      return value;
    }

    function requireCitations(record, key, context) {
      if (!(key in record)) {
        throw new Error(`missing '${key}' in ${context}`);
      }
      const citations = record[key];
      if (!Array.isArray(citations)) {
        throw new Error(`'${key}' must be an array in ${context}`);
      }
      return citations.map((citation, index) => {
        return validateCitationRecord(citation, `${context}.${key}[${index}]`);
      });
    }

    function validateCitationRecord(record, context) {
      const text = requireString(record, "text", context).trim();
      if (text === "") {
        throw new Error(`citation text must not be empty in ${context}`);
      }
      return {
        text,
        filename: requireString(record, "filename", context),
        doc_id: requireString(record, "doc_id", context),
        chunk_id: requireString(record, "chunk_id", context),
        score: requireNumber(record, "score", context),
      };
    }

    function requireErrorMessage(error) {
      if (error instanceof Error) {
        return error.message;
      }
      throw new Error("chat error must be an Error instance");
    }

    function setUploadButtonLoadingState(isLoading) {
      if (typeof isLoading !== "boolean") {
        throw new Error("upload loading state must be a boolean");
      }
      if (isLoading) {
        uploadLoader.classList.remove("hidden");
        uploadButtonLabel.textContent = "Uploading...";
        return;
      }
      uploadLoader.classList.add("hidden");
      uploadButtonLabel.textContent = "Upload";
    }

    function setUploadStatus(statusType, message) {
      if (typeof statusType !== "string") {
        throw new Error("upload status type must be a string");
      }
      if (typeof message !== "string") {
        throw new Error("upload status message must be a string");
      }
      if (statusType === "hidden") {
        uploadStatus.className = "mt-3 hidden rounded-lg border px-3 py-2 text-sm font-medium";
        uploadStatus.textContent = "";
        return;
      }
      if (statusType === "success") {
        uploadStatus.className = "mt-3 rounded-lg border border-emerald-300 bg-emerald-50 px-3 py-2 text-sm font-medium text-emerald-800";
        uploadStatus.textContent = message;
        return;
      }
      if (statusType === "error") {
        uploadStatus.className = "mt-3 rounded-lg border border-red-300 bg-red-50 px-3 py-2 text-sm font-medium text-red-700";
        uploadStatus.textContent = message;
        return;
      }
      if (statusType === "info") {
        uploadStatus.className = "mt-3 rounded-lg border border-zinc-300 bg-zinc-100 px-3 py-2 text-sm font-medium text-zinc-700";
        uploadStatus.textContent = message;
        return;
      }
      throw new Error(`unsupported upload status type: ${statusType}`);
    }

    function initializeChatSessions() {
      const storedState = loadPersistedChatState();
      if (storedState !== null) {
        restoreChatSessions(storedState);
        renderChatHistoryOptions();
        renderActiveSessionMessages();
        return;
      }

      const session = createChatSession("Current Chat");
      chatSessions.push(session);
      setActiveSession(session.id);
      appendAssistantMessage(
        "Hello. I can answer questions from uploaded files and show indexed files under the upload panel.",
        []
      );
      renderChatHistoryOptions();
      renderActiveSessionMessages();
      persistChatState();
    }

    function createChatSession(label) {
      if (typeof label !== "string" || label.trim() === "") {
        throw new Error("chat session label is required");
      }
      return {
        id: createSessionId(),
        label,
        history: [],
        messages: [],
      };
    }

    function createSessionId() {
      if (typeof crypto === "undefined" || typeof crypto.randomUUID !== "function") {
        throw new Error("crypto.randomUUID is required for chat sessions");
      }
      return crypto.randomUUID();
    }

    function loadPersistedChatState() {
      const rawState = localStorage.getItem(CHAT_STORAGE_KEY);
      if (rawState === null) {
        return null;
      }
      const parsedState = JSON.parse(rawState);
      const migratedState = migrateLegacyChatState(parsedState);
      validatePersistedChatState(migratedState);
      if (migratedState !== parsedState) {
        localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify(migratedState));
      }
      return migratedState;
    }

    function validatePersistedChatState(parsedState) {
      if (typeof parsedState !== "object" || parsedState === null) {
        throw new Error("persisted chat state must be an object");
      }
      if (!("activeSessionId" in parsedState)) {
        throw new Error("persisted chat state missing activeSessionId");
      }
      if (!("sessions" in parsedState)) {
        throw new Error("persisted chat state missing sessions");
      }
      if (typeof parsedState.activeSessionId !== "string") {
        throw new Error("persisted activeSessionId must be a string");
      }
      if (!Array.isArray(parsedState.sessions)) {
        throw new Error("persisted sessions must be an array");
      }
    }

    function restoreChatSessions(state) {
      state.sessions.forEach((sessionRecord, index) => {
        validateSessionRecord(sessionRecord, index);
        chatSessions.push({
          id: sessionRecord.id,
          label: sessionRecord.label,
          history: sessionRecord.history,
          messages: sessionRecord.messages,
        });
      });
      if (chatSessions.length === 0) {
        throw new Error("persisted sessions must include at least one chat");
      }
      setActiveSession(state.activeSessionId);
    }

    function validateSessionRecord(sessionRecord, index) {
      const context = `session[${index}]`;
      requireString(sessionRecord, "id", context);
      requireString(sessionRecord, "label", context);
      if (!("history" in sessionRecord) || !Array.isArray(sessionRecord.history)) {
        throw new Error(`missing 'history' array in ${context}`);
      }
      if (!("messages" in sessionRecord) || !Array.isArray(sessionRecord.messages)) {
        throw new Error(`missing 'messages' array in ${context}`);
      }
      sessionRecord.history.forEach((turn, turnIndex) => {
        const turnContext = `${context}.history[${turnIndex}]`;
        const role = requireString(turn, "role", turnContext);
        requireString(turn, "message", turnContext);
        if (role !== "user" && role !== "assistant") {
          throw new Error(`history role must be user or assistant in ${turnContext}`);
        }
      });
      sessionRecord.messages.forEach((entry, messageIndex) => {
        const messageContext = `${context}.messages[${messageIndex}]`;
        const role = requireString(entry, "role", messageContext);
        requireString(entry, "text", messageContext);
        const citations = requireCitations(entry, "citations", messageContext);
        if (!["user", "assistant", "error"].includes(role)) {
          throw new Error(`unsupported message role in ${messageContext}: ${role}`);
        }
        if (role !== "assistant" && citations.length > 0) {
          throw new Error(`non-assistant messages cannot include citations in ${messageContext}`);
        }
      });
    }

    function persistChatState() {
      const payload = {
        activeSessionId,
        sessions: buildPersistableSessions(),
      };
      localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify(payload));
    }

    function buildPersistableSessions() {
      return chatSessions.map((session, index) => {
        const persistableSession = {
          id: session.id,
          label: session.label,
          history: session.history,
          messages: session.messages.filter((entry) => entry.role !== "thinking"),
        };
        validateSessionRecord(persistableSession, index);
        return persistableSession;
      });
    }

    function clearActiveChat() {
      const activeSession = getActiveSession();
      if (activeSession.messages.length === 0 && activeSession.history.length === 0) {
        return;
      }
      activeSession.label = `Chat ${new Date().toLocaleString()}`;
      const newSession = createChatSession("Current Chat");
      chatSessions.unshift(newSession);
      setActiveSession(newSession.id);
      renderChatHistoryOptions();
      renderActiveSessionMessages();
      persistChatState();
    }

    function renderChatHistoryOptions() {
      chatHistorySelect.innerHTML = "";
      chatSessions.forEach((session) => {
        const option = document.createElement("option");
        option.value = session.id;
        option.textContent = session.label;
        if (session.id === activeSessionId) {
          option.selected = true;
        }
        chatHistorySelect.append(option);
      });
    }

    function setActiveSession(sessionId) {
      const session = getSessionById(sessionId);
      activeSessionId = session.id;
      conversationHistory = session.history;
    }

    function getSessionById(sessionId) {
      const session = chatSessions.find((item) => item.id === sessionId);
      if (typeof session === "undefined") {
        throw new Error(`chat session not found: ${sessionId}`);
      }
      return session;
    }

    function getActiveSession() {
      if (activeSessionId === "") {
        throw new Error("active chat session is not set");
      }
      return getSessionById(activeSessionId);
    }

    function appendUserMessage(message) {
      addMessageToActiveSession("user", message, []);
    }

    function appendAssistantMessage(markdownAnswer, citations) {
      addMessageToActiveSession("assistant", removeCitationArtifacts(markdownAnswer), citations);
    }

    function appendThinkingMessage() {
      return addMessageToActiveSession("thinking", "Thinking...", []);
    }

    function appendSystemError(errorText) {
      addMessageToActiveSession("error", errorText, []);
    }

    function addMessageToActiveSession(role, text, citations) {
      if (typeof role !== "string") {
        throw new Error("message role must be a string");
      }
      if (typeof text !== "string") {
        throw new Error("message text must be a string");
      }
      if (!Array.isArray(citations)) {
        throw new Error("message citations must be an array");
      }
      if (role !== "assistant" && citations.length > 0) {
        throw new Error("only assistant messages can include citations");
      }
      const validatedCitations = citations.map((citation, index) => {
        return validateCitationRecord(citation, `new_message.citations[${index}]`);
      });
      const session = getActiveSession();
      const messageId = createSessionId();
      session.messages.push({
        id: messageId,
        role,
        text,
        citations: validatedCitations,
      });
      renderActiveSessionMessages();
      persistChatState();
      return messageId;
    }

    function removeMessageById(messageId) {
      const session = getActiveSession();
      const entryIndex = session.messages.findIndex((entry) => entry.id === messageId);
      if (entryIndex === -1) {
        throw new Error(`chat message not found: ${messageId}`);
      }
      session.messages.splice(entryIndex, 1);
      renderActiveSessionMessages();
      persistChatState();
    }

    function renderActiveSessionMessages() {
      const session = getActiveSession();
      chatWindow.innerHTML = "";
      session.messages.forEach((entry) => {
        chatWindow.append(buildMessageElement(entry));
      });
      scrollChatToBottom();
    }

    function buildMessageElement(entry) {
      if (!("role" in entry) || !("text" in entry) || !("citations" in entry)) {
        throw new Error("chat entry must include role, text, and citations");
      }
      if (entry.role === "user") {
        return buildUserMessageElement(entry.text);
      }
      if (entry.role === "assistant") {
        if (!Array.isArray(entry.citations)) {
          throw new Error("assistant entry citations must be an array");
        }
        return buildAssistantMessageElement(entry.text, entry.citations);
      }
      if (entry.role === "thinking") {
        return buildThinkingMessageElement();
      }
      if (entry.role === "error") {
        return buildErrorMessageElement(entry.text);
      }
      throw new Error(`unsupported chat entry role: ${entry.role}`);
    }

    function buildUserMessageElement(message) {
      const row = document.createElement("div");
      row.className = "mb-3 flex justify-end";
      const wrapper = document.createElement("article");
      wrapper.className = "max-w-[85%] rounded-xl border border-zinc-300 bg-zinc-200/90 p-3";
      wrapper.innerHTML = `<p class="text-right text-xs font-semibold uppercase tracking-wide text-zinc-600">You</p><p class="mt-1 text-right text-sm text-zinc-900">${escapeHtml(message)}</p>`;
      row.append(wrapper);
      return row;
    }

    function buildAssistantMessageElement(markdownAnswer, citations) {
      const row = document.createElement("div");
      row.className = "mb-3 flex justify-start";
      const wrapper = document.createElement("article");
      wrapper.className = "max-w-[85%] rounded-xl border border-red-200 bg-white p-3 shadow-sm";
      wrapper.innerHTML = "<p class=\"text-xs font-semibold uppercase tracking-wide text-red-600\">Assistant</p><div class=\"markdown-body mt-2 text-sm text-zinc-800\"></div>";
      const markdownContainer = wrapper.querySelector(".markdown-body");
      if (markdownContainer === null) {
        throw new Error("assistant markdown container is required");
      }
      markdownContainer.innerHTML = renderMarkdown(removeCitationArtifacts(markdownAnswer));
      applyDocumentHighlights(markdownContainer, citations);
      row.append(wrapper);
      return row;
    }

    function buildThinkingMessageElement() {
      const row = document.createElement("div");
      row.className = "mb-3 flex justify-start";
      const wrapper = document.createElement("article");
      wrapper.className = "max-w-[85%] rounded-xl border border-zinc-200 bg-white p-3 shadow-sm";
      wrapper.innerHTML = "<p class=\"text-xs font-semibold uppercase tracking-wide text-zinc-500\">Assistant</p><p class=\"mt-2 text-sm text-zinc-600 animate-pulse\">Thinking...</p>";
      row.append(wrapper);
      return row;
    }

    function buildErrorMessageElement(errorText) {
      const row = document.createElement("div");
      row.className = "mb-3 flex justify-start";
      const wrapper = document.createElement("article");
      wrapper.className = "max-w-[85%] rounded-xl border border-red-300 bg-red-50 p-3";
      wrapper.innerHTML = `<p class="text-xs font-semibold uppercase tracking-wide text-red-600">Error</p><p class="mt-1 text-sm text-red-700">${escapeHtml(errorText)}</p>`;
      row.append(wrapper);
      return row;
    }

    async function fetchAssistantResponse(message, history) {
      const response = await fetch("/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ message, history }),
      });
      const payload = await response.json();
      if (!response.ok) {
        throw new Error(requireString(payload, "detail", "chat error"));
      }
      const answer = requireString(payload, "answer", "chat response");
      if (!("grounded" in payload) || typeof payload.grounded !== "boolean") {
        throw new Error("'grounded' must be a boolean in chat response");
      }
      requireNumber(payload, "retrieved_count", "chat response");
      const citations = requireCitations(payload, "citations", "chat response");
      const cleanedAnswer = removeCitationArtifacts(answer).trim();
      if (cleanedAnswer === "") {
        throw new Error("chat returned an empty answer");
      }
      return { answer: cleanedAnswer, citations };
    }

    async function loadDocuments() {
      documentsStatus.textContent = "Refreshing indexed documents...";
      const response = await fetch("/documents");
      const payload = await response.json();
      if (!response.ok) {
        documentsStatus.textContent = `Failed to load documents: ${requireString(payload, "detail", "document list error")}`;
        return;
      }
      if (!("documents" in payload) || !Array.isArray(payload.documents)) {
        throw new Error("missing 'documents' array in document list response");
      }
      renderDocuments(payload.documents);
    }

    function renderDocuments(documents) {
      documentsList.innerHTML = "";
      if (documents.length === 0) {
        const emptyItem = document.createElement("li");
        emptyItem.className = "rounded-md border border-zinc-200 bg-zinc-50 px-3 py-2 text-sm text-zinc-500";
        emptyItem.textContent = "No indexed documents yet.";
        documentsList.append(emptyItem);
        documentsStatus.textContent = "0 indexed documents.";
        return;
      }

      documents.forEach((documentRecord, index) => {
        const context = `document[${index}]`;
        const filename = requireString(documentRecord, "filename", context);
        const docId = requireString(documentRecord, "doc_id", context);
        const row = document.createElement("li");
        row.className = "flex items-center justify-between gap-3 rounded-md border border-zinc-200 bg-zinc-50 px-3 py-2";
        row.innerHTML = `
          <span class="truncate text-sm font-medium text-zinc-800">${escapeHtml(filename)}</span>
          <button
            class="delete-document rounded-md border border-red-300 bg-white px-2.5 py-1.5 text-xs font-semibold text-red-700 transition hover:bg-red-50"
            type="button"
            data-doc-id="${escapeHtml(docId)}"
          >
            Delete
          </button>
        `;
        const deleteButton = row.querySelector(".delete-document");
        if (deleteButton === null) {
          throw new Error("missing delete button in document row");
        }
        deleteButton.addEventListener("click", async () => {
          await deleteDocument(docId, filename);
        });
        documentsList.append(row);
      });
      documentsStatus.textContent = `${documents.length} indexed document(s).`;
    }

    async function deleteDocument(docId, filename) {
      const shouldDelete = window.confirm(`Delete '${filename}' and remove its indexed chunks?`);
      if (!shouldDelete) {
        return;
      }
      documentsStatus.textContent = `Deleting ${filename}...`;
      const response = await fetch(`/documents/${encodeURIComponent(docId)}`, {
        method: "DELETE",
      });
      const payload = await response.json();
      if (!response.ok) {
        documentsStatus.textContent = `Delete failed: ${requireString(payload, "detail", "delete document error")}`;
        return;
      }
      const chunksDeleted = requireNumber(payload, "chunks_deleted", "delete document response");
      documentsStatus.textContent = `Deleted ${filename}. Removed ${chunksDeleted} chunk(s) from index.`;
      await loadDocuments();
    }

    function renderMarkdown(markdownText) {
      const html = marked.parse(markdownText);
      return DOMPurify.sanitize(html);
    }

    function removeCitationArtifacts(text) {
      if (typeof text !== "string") {
        throw new Error("citation cleanup input must be a string");
      }
      return text.replace(CITATION_ARTIFACT_PATTERN, "").replace(/[ \t]{2,}/g, " ").trimStart();
    }

    function escapeHtml(value) {
      return value
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll("\"", "&quot;")
        .replaceAll("'", "&#39;");
    }

    function scrollChatToBottom() {
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }
  </script>
</body>
</html>
